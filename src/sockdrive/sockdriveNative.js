R"'''((()=>{"use strict";const e=1048576;function t(e,t){if(e.data instanceof ArrayBuffer){let s=new Uint8Array(e.data);0===t.payloadSize&&(t.payloadSize=s[0]+(s[1]<<8)+(s[2]<<16)+(s[3]<<24),s=s.slice(4));const r=t.payloadSize-t.payloadPos;if(s.byteLength>r||r<0)return t.error="wrong read payload length "+s.byteLength+" instead of "+r,!0;if(t.payload.set(s,t.payloadPos),t.payloadPos+=s.byteLength,t.payloadPos==t.payloadSize){const e=t.aheadSize*t.sectors.length;let s=e;return t.payloadSize<e?s=function(e,t,s,r){let i,o,n;for(i=s=s||0,o=r=r||e.length-s,n=0;i<o;){const s=e[i++];let r=s>>4;if(r>0){let s=r+240;for(;255===s;)s=e[i++],r+=s;const a=i+r;for(;i<a;)t[n++]=e[i++];if(i===o)return n}const a=e[i++]|e[i++]<<8;if(0===a)return n;if(a>n)return-(i-2);let h=15&s,c=h+240;for(;255===c;)c=e[i++],h+=c;let l=n-a;const d=n+h+4;for(;n<d;)t[n++]=t[l++]}return n}(t.payload,t.sectorsRow,0,t.payloadSize):t.sectorsRow.set(t.payload),s!=e&&(t.error="wrong decode result "+s+" should be "+e),!0}return!1}return t.error="received non arraybuffer data",!0}var s=function(e,t,s,r){return new(s||(s=Promise))((function(i,o){function n(e){try{h(r.next(e))}catch(e){o(e)}}function a(e){try{h(r.throw(e))}catch(e){o(e)}}function h(e){var t;e.done?i(e.value):(t=e.value,t instanceof s?t:new s((function(e){e(t)}))).then(n,a)}h((r=r.apply(e,t||[])).next())}))};class r{constructor(e,t,s,r,i,o,n=null,a=!1){var h;this.socket=Promise.resolve(null),this.aheadRange=0,this.aheadSize=0,this.readStartedAt=0,this.cleanup=()=>{},this.openFn=(e,t,s,r,i,o)=>{},this.errorFn=e=>{},this.readOnly=!1,this.alive=!0,this.lastBufferedAmount=0,this.statsDirty={},this.sectorSize=512,this.module=o,this.endpoint=e,this.owner=t,this.drive=s,this.realOwner=t,this.realDrive=s,this.token=r,this.request=null,this.readBuffer=new Uint8Array(9),this.writeBuffer=new Uint8Array(5+this.sectorSize),this.stats=i,this.cache=n,null===(h=this.cache)||void 0===h||h.open(this.owner,this.drive,this.token),this.frame=null,this.readBuffered=a,this.reconnect(),this.statsCommitInterval=setInterval((()=>{Object.keys(this.statsDirty).length>0&&(fetch(e.replace("wss://","https://").replace("ws://","http://")+"/cache/set/"+encodeURIComponent(this.realOwner)+"/"+encodeURIComponent(this.realDrive)+"/"+(0===r.length?"guest":r),{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(this.statsDirty)}).catch((e=>console.warn("Can't send drive cache stats",e))),this.statsDirty={})}),6e4)}onError(e){this.errorFn=e}onOpen(e){this.openFn=e}reconnect(){this.alive&&(this.socket&&this.socket.then((e=>{null!==e&&e.close()})),this.socket=new Promise(((e,t)=>{const s=new WebSocket(this.endpoint);s.binaryType="arraybuffer";const r=this.onMessage.bind(this),i=()=>{const i=o=>{var n;if(s.removeEventListener("message",i),o.data.startsWith("write")||o.data.startsWith("read")){const[t,i,n,a,h]=o.data.split(",");this.realOwner=a,this.realDrive=h,this.aheadRange=Number.parseInt(i),this.aheadSize=this.aheadRange*this.sectorSize,this.readOnly="write"!==t,this.frame={sectors:[],sectorsRow:new Uint8Array(this.aheadSize),payload:new Uint8Array(this.aheadSize),payloadPos:0,payloadSize:0,aheadSize:this.aheadSize};const c=t=>{var i;s.removeEventListener("message",c),s.addEventListener("message",r),this.openFn(!0,!this.readOnly,1024*(null!==(i=Number.parseInt(n))&&void 0!==i?i:2097152),this.aheadRange,a,h),this.onOpen=()=>{},this.errorFn=()=>{},e(s)};s.addEventListener("message",c)}else{const e=new Error(null!==(n=o.data)&&void 0!==n?n:"Unable to establish connection");this.errorFn(e),t(e)}};s.addEventListener("message",i),s.send(this.owner+"&"+this.drive+"&"+this.token)},o=e=>{console.error("Network error",e,"will reconnect"),n(),s.close(),setTimeout(this.reconnect.bind(this),300)};s.addEventListener("error",o),s.addEventListener("open",i);const n=function(){s.removeEventListener("message",r),s.removeEventListener("open",i),s.removeEventListener("error",o)};this.cleanup=n})),null!==this.request&&this.executeRequest(this.request))}read(e,t,s){var r,i;const o=this.getOrigin(e);this.statsDirty[o]=(null!==(r=this.statsDirty[o])&&void 0!==r?r:0)+1;const n=null===(i=this.cache)||void 0===i?void 0:i.read(this.owner,this.drive,e);return n?(this.stats.cacheHit++,this.module.HEAPU8.set(this.readBuffered||n.length==this.sectorSize?n:n.slice(0,this.sectorSize),t),s?0:Promise.resolve(0)):s?255:new Promise((s=>{this.stats.cacheMiss++;const r={type:1,sector:e,buffer:t,resolve:s};null!==this.request?(console.error("New read request while old one is still processed"),s(3)):(this.request=r,this.executeRequest(this.request))}))}write(e,t){var s;const r={type:2,sector:e,buffer:this.module.HEAPU8.slice(t,t+this.sectorSize),resolve:()=>{}};return this.lastBufferedAmount+=this.sectorSize,null===(s=this.cache)||void 0===s||s.write(this.owner,this.drive,e,r.buffer),this.executeRequest(r),0}close(){return s(this,void 0,void 0,(function*(){clearInterval(this.statsCommitInterval),this.alive=!1;const e=yield this.socket;yield new Promise((t=>{const s=setInterval((()=>{0===e.bufferedAmount&&(clearInterval(s),t())}),32)})),this.cleanup(),e.close()}))}executeRequest(e){this.socket.then((t=>s(this,void 0,void 0,(function*(){if(t.readyState!==WebSocket.CLOSED&&t.readyState!==WebSocket.CLOSING)if(1===e.type){const{sector:s}=e;this.readStartedAt=Date.now(),this.readBuffer[0]=1,this.readBuffer[1]=1,this.readBuffer[2]=0,this.readBuffer[3]=0,this.readBuffer[4]=0;const r=this.getOrigin(s);this.readBuffer[5]=255&r,this.readBuffer[6]=r>>8&255,this.readBuffer[7]=r>>16&255,this.readBuffer[8]=r>>24&255,this.frame.sectors=[s],this.frame.payloadPos=0,this.frame.payloadSize=0,t.send(this.readBuffer.slice(0,9).buffer)}else if(this.readOnly)e.resolve(0);else{const{sector:s,buffer:r,resolve:i}=e;this.stats.write+=this.sectorSize,this.writeBuffer[0]=2,this.writeBuffer[1]=255&s,this.writeBuffer[2]=s>>8&255,this.writeBuffer[3]=s>>16&255,this.writeBuffer[4]=s>>24&255,this.writeBuffer.set(r,5),t.send(this.writeBuffer.buffer),i(0)}else this.alive?(console.error("Drive connection to '"+this.owner+"/"+this.drive+"' was closed, trying to reconnect..."),this.reconnect()):(console.error("Trying to read from closed drive",this.drive),e.resolve(4))})))).catch(console.error)}onMessage(e){var s;if(null===this.request)console.error("Received message without request"),this.reconnect();else if(2===this.request.type)console.error("Received read payload while write request"),this.reconnect();else if(t(e,this.frame)){if(this.frame.error)return console.error(this.frame.error),void this.reconnect();{const{buffer:e,sector:t,resolve:r}=this.request,i=this.getOrigin(t);null===(s=this.cache)||void 0===s||s.update(this.owner,this.drive,i,this.frame.sectorsRow,0);const o=(t-i)*this.sectorSize;this.readBuffered?0!==o?(console.error("Buffered mode only works for origin!"),r(3)):this.module.HEAPU8.set(this.frame.sectorsRow,e):this.module.HEAPU8.set(this.frame.sectorsRow.slice(o,o+this.sectorSize),e),this.stats.read+=this.frame.payloadSize,this.stats.readTotalTime+=Date.now()-this.readStartedAt,this.request=null,r(0)}}}currentSocket(){return this.socket}getOrigin(e){return e-e%this.aheadRange}bufferedAmount(){return this.socket.then((e=>{e&&(this.lastBufferedAmount=e.bufferedAmount)})),this.lastBufferedAmount}}const i=Symbol("newer"),o=Symbol("older");class n{constructor(e,t){"number"!=typeof e&&(t=e,e=0),this.size=0,this.limit=e,this.oldest=this.newest=void 0,this._keymap=new Map,t&&(this.assign(t),e<1&&(this.limit=this.size))}_markEntryAsUsed(e){e!==this.newest&&(e[i]&&(e===this.oldest&&(this.oldest=e[i]),e[i][o]=e[o]),e[o]&&(e[o][i]=e[i]),e[i]=void 0,e[o]=this.newest,this.newest&&(this.newest[i]=e),this.newest=e)}assign(e){let t,s=this.limit||Number.MAX_VALUE;this._keymap.clear();const r=e[Symbol.iterator]();for(let e=r.next();!e.done;e=r.next()){const r=new a(e.value[0],e.value[1]);if(this._keymap.set(r.key,r),t?(t[i]=r,r[o]=t):this.oldest=r,t=r,0==s--)throw new Error("overflow")}this.newest=t,this.size=this._keymap.size}get(e){const t=this._keymap.get(e);if(t)return this._markEntryAsUsed(t),t.value}set(e,t){let s=this._keymap.get(e);return s?(s.value=t,this._markEntryAsUsed(s),this):(this._keymap.set(e,s=new a(e,t)),this.newest?(this.newest[i]=s,s[o]=this.newest):this.oldest=s,this.newest=s,++this.size,this.size>this.limit&&this.shift(),this)}shift(){const e=this.oldest;if(e)return this.oldest[i]?(this.oldest=this.oldest[i],this.oldest[o]=void 0):(this.oldest=void 0,this.newest=void 0),e[i]=e[o]=void 0,this._keymap.delete(e.key),--this.size,[e.key,e.value]}}function a(e,t){this.key=e,this.value=t,this[i]=void 0,this[o]=void 0}function h(e){this.entry=e}function c(e){this.entry=e}function l(e){this.entry=e}h.prototype[Symbol.iterator]=function(){return this},h.prototype.next=function(){const e=this.entry;return e?(this.entry=e[i],{done:!1,value:[e.key,e.value]}):{done:!0,value:void 0}},c.prototype[Symbol.iterator]=function(){return this},c.prototype.next=function(){const e=this.entry;return e?(this.entry=e[i],{done:!1,value:e.key}):{done:!0,value:void 0}},l.prototype[Symbol.iterator]=function(){return this},l.prototype.next=function(){const e=this.entry;return e?(this.entry=e[i],{done:!1,value:e.value}):{done:!0,value:void 0}};class d{constructor(e,t,s){this.aheadRange=t,this.sectorSize=e,this.aheadSize=t*e,this.lru=new n(Math.floor(s/(t*e)))}contains(e){return!!this.lru.get(e)}read(e){const t=this.getOrigin(e),s=this.lru.get(t);if(s){const r=e-t;return 0===r?s:s.slice(r*this.sectorSize,(r+1)*this.sectorSize)}return null}create(e,t,s){this.lru.set(e,t.slice(s,s+this.aheadSize))}getOrigin(e){return e-e%this.aheadRange}memUsed(){return this.lru.size*this.aheadSize}}class u{constructor(s,r,i,o,n,a,h){this.cache=null,this.writeCache={},this.socket=null,this.connect=()=>new Promise((c=>{const l=new WebSocket(s);this.socket=l,l.addEventListener("close",(()=>{c()})),l.binaryType="arraybuffer",l.addEventListener("error",(()=>{console.error("Can't connect to",s,r,i),l.close()})),l.addEventListener("open",(()=>{l.addEventListener("message",(s=>{const o=new Uint32Array(s.data);if(3!==(null==o?void 0:o.length))console.error("Wrong cache format");else{const s=o[0],c=o[1];if(this.cache=new d(s,c,67108864),!n)return void l.close();let u=o[2];if(0===u)l.close();else{const o=s*c,n=Math.floor(e/o),d={payload:new Uint8Array(e),sectorsRow:new Uint8Array(e),aheadSize:c*s,sectors:[],payloadSize:0,payloadPos:0},f=u*o;let v=f;a(r,i,v,f),l.addEventListener("message",(e=>{var y,p;if(e.data instanceof ArrayBuffer){const m=new Uint8Array(e.data);if(0===d.sectors.length){const e=m[1]+(m[2]<<8)+(m[3]<<16)+(m[4]<<24);if(e>n)return console.error("Can't load more than",n,"at once (requested"+e+")"),void l.close();for(let t=0;t<e;++t){const e=5+4*t;d.sectors.push(m[e]+(m[e+1]<<8)+(m[e+2]<<16)+(m[e+3]<<24))}}else if(t(e,d))if(d.error)console.error(d.error),l.close();else{h(r,i,s,c,d.sectors,d.sectorsRow),v-=d.sectors.length*o,u-=d.sectors.length,a(r,i,v,f);for(let e=0;e<d.sectors.length;++e)(null===(y=this.cache)||void 0===y?void 0:y.contains(d.sectors[e]))||null===(p=this.cache)||void 0===p||p.create(d.sectors[e],d.sectorsRow,e*d.aheadSize);d.sectors=[],d.payloadSize=0,d.payloadPos=0,0===u&&l.close()}}else console.error("Unknown event",e),l.close()}))}}}),{once:!0}),l.send(r+"&"+i+"&"+o)}))}))}read(e){var t,s,r;return null!==(r=null!==(t=this.writeCache[e])&&void 0!==t?t:null===(s=this.cache)||void 0===s?void 0:s.read(e))&&void 0!==r?r:null}write(e,t){this.writeCache[e]=t}create(e,t,s){var r;null===(r=this.cache)||void 0===r||r.create(e,t,s)}getOrigin(e){var t,s;return null!==(s=null===(t=this.cache)||void 0===t?void 0:t.getOrigin(e))&&void 0!==s?s:0}memUsed(){var e,t;return null!==(t=null===(e=this.cache)||void 0===e?void 0:e.memUsed())&&void 0!==t?t:0}close(){var e;null===(e=this.socket)||void 0===e||e.close()}}class f{key(e,t){return e+"/"+t}constructor(e,t){this.impl={},this.progress=()=>{},this.payload=()=>{},this.connectQueue=[],this.url=e,this.preload=t}open(e,t,s){const r=this.key(e,t);if(void 0===this.impl[r]){const i=new u(this.url+"/cache",e,t,s,this.preload,this.progress,this.payload);this.impl[r]=i,this.connectQueue.push(i.connect),1==this.connectQueue.length&&this.runNextCache()}}runNextCache(){if(this.connectQueue.length>0){const e=this.connectQueue[0];e().then((()=>{e===this.connectQueue[0]?(this.connectQueue.splice(0,1),this.runNextCache()):console.error("wrong cache order!")}))}}read(e,t,s){const r=this.key(e,t);return this.impl[r]?this.impl[r].read(s):(console.error("Cache for drive",r,"not opened!"),null)}update(e,t,s,r,i){const o=this.key(e,t);if(this.impl[o]){const e=this.impl[o].getOrigin(s);if(e&&e!==s)throw new Error("Origin mistamtch for "+o);this.impl[o].create(s,r,i)}else console.error("Cache for drive",o,"not opened!")}write(e,t,s,r){const i=this.key(e,t);this.impl[i]?this.impl[i].write(s,r):console.error("Cache for drive",i,"not opened!")}memUsed(){let e=0;for(const t of Object.keys(this.impl))e+=this.impl[t].memUsed();return e}onProgress(e){this.progress=e}onPayload(e){this.payload=e}close(){for(const e of Object.keys(this.impl))this.impl[e].close()}}!function(){let e=0;const t={},s={},i={read:0,write:0,readTotalTime:0,cacheHit:0,cacheMiss:0,cacheUsed:0,io:[]},o={};Module.sockdrive={stats:i,cache:o,createCache:(e,t)=>new f(e,t),onError:e=>{console.error(e)},onOpen:(e,t,s)=>{},open:(n,a,h,c)=>{return l=this,d=void 0,f=function*(){const l=yield fetch(n.replace("wss://","https://").replace("ws://","http://")+"/template/"+a+"/"+h),d=yield l.json();if(d.error)throw new Error(d.error);return e++,s[e]=d,i.io.push({read:0,write:0}),new Promise(((s,l)=>{var d;const u=null!==(d=o[n])&&void 0!==d?d:null;u?u.open(a,h,c):console.error("sockdrive cache not found for",n),t[e]=new r(n,a,h,c,i,Module,u),t[e].onOpen(((t,r,i,o,n,c)=>{Module.sockdrive.onOpen((null!=n?n:a)+"/"+(null!=c?c:h),t,r,i,o),s(e)})),t[e].onError((e=>{Module.sockdrive.onError(e),l(e)}))}))},new((u=void 0)||(u=Promise))((function(e,t){function s(e){try{i(f.next(e))}catch(e){t(e)}}function r(e){try{i(f.throw(e))}catch(e){t(e)}}function i(t){var i;t.done?e(t.value):(i=t.value,i instanceof u?i:new u((function(e){e(i)}))).then(s,r)}i((f=f.apply(l,d||[])).next())}));var l,d,u,f},read:(e,s,r,o)=>t[e]?(i.io[e-1].read+=1,t[e].read(s,r,o)):(console.error("ERROR! sockdrive handle",e,"not found"),o?1:Promise.resolve(1)),write:(e,s,r)=>t[e]?(i.io[e-1].write+=1,t[e].write(s,r)):(console.error("ERROR! sockdrive handle",e,"not found"),1),close:e=>{t[e]&&(t[e].close(),delete t[e])},size:e=>{var t,r;return null!==(r=null===(t=s[e])||void 0===t?void 0:t.size)&&void 0!==r?r:0},sector_size:e=>{var t,r;return null!==(r=null===(t=s[e])||void 0===t?void 0:t.sector_size)&&void 0!==r?r:512},heads:e=>{var t,r;return null!==(r=null===(t=s[e])||void 0===t?void 0:t.heads)&&void 0!==r?r:1},cylinders:e=>{var t,r;return null!==(r=null===(t=s[e])||void 0===t?void 0:t.cylinders)&&void 0!==r?r:520},sectors:e=>{var t,r;return null!==(r=null===(t=s[e])||void 0===t?void 0:t.sectors)&&void 0!==r?r:63},bufferedAmount:()=>{let e=0;for(const s of Object.values(t))e+=s.bufferedAmount();return e}}}()})();
//# sourceMappingURL=sockdriveNative.js.map)'''"